# Login interactive shell: /etc/bash then ~/.bash_profile
# Non-log shell: execute ~/.bashrc only
# Non-interactive shell: execute sript pointed by $ENV, nothing if $ENV = ""
[ -z "PS1" ] && return					#nothing to do for non interactive shell
PS1="\h:\W> "						#prompt: hostname:dirname>

export PATH="$HOME:/usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin"
export MY_USER=kshileev
export MY_TMP_DIR=/tmp/${MY_USER}
export MY_DIR=$(cd $(dirname "${BASH_SOURCE:-$0}") && pwd)
export MY_BASH_RC=${MY_DIR}/RcBash
export MY_VIM_RC=${MY_DIR}/RcVim
export SYSSCREENRC=${MY_DIR}/RcScreen
mkdir -p ${MY_TMP_DIR}
export MY_CSCOPE_DIR=${MY_TMP_DIR}/cscope		#tmp dir where cscope stores the output
export MY_CSCOPE_FILE_LIST=${MY_CSCOPE_DIR}/cscope.files	#file to list files to browse into db
export LESSHISTFILE=${MY_TMP_DIR}/LessHist
export HISTFILE=${MY_TMP_DIR}/BashHist
export HISTSIZE=5000
export HISTCONTROL=ignoreboth
export X509_USER_CERT=${MY}/KirINFN.pem		#certificate used by globus
export X509_USER_KEY=${MY}/KirPrivate.pem	#private key for this certificate
export SIMPLE_BACKUP_SUFFIX=.${MY_USER}		#used by patch to store initial state of touched files
export DISTCC_HOSTS='1.1.1.1 2.2.2.2 3.3.3.3'	#used by make -j
export ARTISTIC_STYLE_OPTIONS=${MY_DIR}/RcAstyle
export LD_LIBRARY_PATH=$HOME
export ROOTGUI=native
[ -d $HOME/ElasticLoadBalancing ] && AWS_ELB_HOME=$HOME
ColorNormal="\\033[0;39m"
ColorBlack="\\033[0;30m";     ColorDarkGray="\\033[1;30m"
ColorBlue="\\033[0;34m";      ColorLightBlue="\\033[1;34m"
ColorGreen="\\033[0;32m";     ColorLightGreen="\\033[1;32m"
ColorCyan="\\033[0;36m";      ColorLightCyan="\\033[1;36m"
ColorRed="\\033[0;31m";       ColorLightRed="\\033[1;31m"
ColorPurple="\\033[0;35m";    ColorLightPurple="\\033[1;35m"
ColorBrown="\\033[0;33m";     ColorYellow="\\033[1;33m"
ColorLightGray="\\033[0;37m"; ColorWhite="\\033[1;37m"

setcolor_caption="echo -en \\033[1;34m"
setcolor_success="echo -en \\033[1;32m"
setcolor_failure="echo -en \\033[1;31m"
setcolor_normal="echo -en \\033[0;39m"


_ecount=0
function _e()
{
	_ecount=$((_ecount+1))
	${setcolor_caption}
	echo -n "Phase #$_ecount: $*..."
	${setcolor_normal}
	echo
}
function _eok()
{
	${setcolor_success}
	echo -n "DONE"
	${setcolor_normal}
	echo
}
function _enok()
{
	${setcolor_failure}
	echo -n "FAILED"
	${setcolor_normal}
	echo
}
function ksPrintSeparator()
{
    printf "%0.s-" {1..80}
    echo
}
function ksPrintDevstackStatus()
{
    local log_file=`find ~/os /opt -name stack.sh.log 2>/dev/null`
    grep -q "This is your host ip:" 2>/dev/null ${log_file} && ${setcolor_success} || ${setcolor_failure}
    echo -n DS
    ${setcolor_normal}
    echo
}
function ksAddLineToFileIfNotThere()
{
    local line=$1
    local file=$2
    echo $line
    [ -f ${file} ] || touch ${file}
    grep "${line}" ${file} || echo ${line} >> ${file}
}
function ksMacRandom()
{
    echo $(od -An -N6 -tx1 /dev/urandom | sed -e 's/^  *//' -e 's/  */:/g' -e 's/:$//' -e 's/^\(.\)[13579bdf]/\10/')
}
function ksVirtVm()
{
    local vm_name='build_server'
    local vm_disk_format=raw
    local vm_disk_path=${MY_TMP_DIR}/${vm_name}.${vm_disk_format}
    local vm_iso_path=/opt/trusty-server-cloudimg-amd64-disk1.img

    virt-install --name ${vm_name} --ram 4096 --arch=i686 --vcpus=1 --hvm --graphics vnc \
        --os-variant ubuntutrusty \
        --cdrom ${vm_iso_path} \
        --disk path=${vm_disk_path},bus=virtio,size=20,sparse=false,format=${vm_disk_format}
}
function ksVirtStatus()
{
    echo Virtual machines: &&  virsh list --all
    echo Virtual pools: && virsh pool-list --all
    echo Virtual networks: &&  virsh net-list --all
    echo Bridges: && brctl show
    ksPrintSeparator
    local server=$(virsh list | grep lab | awk '{print $2}')
    alias v1="virsh console ${server}"
    alias v2="virsh vncdisplay ${server}"
}
function ksVirt()
{
    ksVirtStatus

    local virsh_command=$(ksGetChoice 'kill-all new-vm')
    case ${virsh_command} in
        kill-all)
	         virsh list | awk '{print $2}' | grep -v ^Name | xargs -n 1 virsh destroy
	         virsh list --all | awk '{print $2}' | grep -v ^Name | xargs -n 1 virsh undefine
	         virsh net-list | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh net-destroy
	         virsh net-list --all | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh net-undefine
	         virsh pool-list | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh pool-destroy
	         virsh pool-list --all | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh pool-undefine
	       ;;
        new-vm) ksVirtVm ;;
    esac
}
function ks_list_of_ifaces()
{
    echo $(ip l |grep UP | cut -f2 -d ':')
}
function ksNet()
{
    local net_cmd=$(ksGetChoice 'sh-kern tcpdump del-nic del-netns')
    echo ${net_cmd}
    case ${net_cmd} in
    sh-kern)
	sudo sysctl -a | grep forward
	echo
	sudo sysctl -a |grep bridge
	echo
	sudo sysctl -a | grep use_tempaddr
	;;
    tcpdump)
	ifaces=$(ks_list_of_ifaces)
	iface=$(ksGetChoice "${ifaces}")
	filter=$(ksGetChoice 'icmp6 dns')
	case ${filter} in
	    dns) filter='port 53' ;;
	esac
	sudo tcpdump -n -e -l -i ${iface} ${filter} -vv
	;;
    del-nic)
	ip a
	local re=$(ksGetInput 'enter re' 'q.*')
	for interface in `ip a | grep -E ${re}: | cut -f2 -d ':'`; do
	    echo Deleting interface ${interface}...
	    sudo ip l d ${interface}
	done
    ;;
    del-netns)
	for namespace in `ip net`; do
	    echo Deleting namespace ${namespace}...
	    sudo ip net d ${namespace}
	done
    ;;
    esac
}
function ksGetInput()
{
    local text=$1
    local default=$2
    local input
    read -p "${text} [default=${default}]: " input
    echo ${input:-${default}}
}
function ksGetChoice()
{
    local commands=$1
    local command=$2
    [[ -n ${command} ]] && [[ ${commands} == *${command}* ]] && echo ${command} && return
    local default_command=$(echo ${commands} | cut -d ' ' -f1)
    local input
    read -p "choose from ${commands} [default=${default_command}]: " input
    [[ ${commands} != *${input}* ]] && echo Wrong command ${input} 1>&2 && return
    echo ${input:-${default_command}}
}
function ksNova()
{
    local nova_command=${1:-$(ksGetChoice 'config status')}
    case ${nova_command} in
        config)
            local devstack_config=$(find ~ -wholename '*/devstack/openrc')
            export OS_TENANT_NAME=demo
            export OS_USERNAME=demo
            export OS_PASSWORD=password
            export OS_AUTH_URL='http://localhost:5000/v2.0'
	    [ -z ${devstack_config} ] || source ${devstack_config}
        ;;
        status)
	    echo Tenant: ${OS_TENANT_NAME} User: ${OS_USER_NAME}
            nova list
	    neutron net-list
	    neutron subnet-list
	    neutron port-list
        ;;
    esac
}
function ksDevstack()
{
    local devstack_command=$(ksGetChoice 'config run result cleanup' $1)
    case ${devstack_command} in
    config)
            local conf_file_name=local.conf
	    cat > ${conf_file_name} <<EOF
[[local|localrc]]
DEST=\${HOME}/os
DATA_DIR=\${DEST}/data
SERVICE_DIR=\${DEST}/status
GIT_BASE=https://git.openstack.org
TEMPEST_REPO=https://github.com/CiscoSystems/tempest.git
TEMPEST_BRANCH=ipv6
RECLONE=True

MYSQL_PASSWORD=nova
RABBIT_PASSWORD=nova
SERVICE_TOKEN=nova
SERVICE_PASSWORD=nova
ADMIN_PASSWORD=nova

ENABLED_SERVICES=g-api,g-reg,key,n-api,n-crt,n-obj,n-cpu,n-cond,cinder,c-sch,c-api,c-vol,n-sch,n-novnc,n-xvnc,n-cauth,horizon,rabbit
enable_service mysql
disable_service n-net
enable_service q-svc
enable_service q-agt
enable_service q-l3
enable_service q-dhcp
enable_service q-meta
enable_service q-lbaas
enable_service neutron
enable_service tempest

NOVA_USE_NEUTRON_API=v2
VOLUME_BACKING_FILE_SIZE=2052M
API_RATE_LIMIT=False

VERBOSE=True
DEBUG=True

LOGFILE=\$DEST/logs/stack.sh.log
USE_SCREEN=True
SCREEN_LOGDIR=\$DEST/logs

IP_VERSION=4+6
IPV6_PUBLIC_RANGE=2005::/64
IPV6_PUBLIC_NETWORK_GATEWAY=2005::1
REMOVE_PUBLIC_BRIDGE=False
EOF
                   echo ${conf_file_name} created
        ;;
    run)
	cat ~/current_tempest && cd /opt/stack/tempest && testr run --load-list=${HOME}/current_tempest
	;;
    result)
            testr last --subunit | subunit-1to2 | subunit2junitxml --output-to=kir_results.xml
        ;;
    cleanup)
	sudo rm -rf /etc/keystone /usr/local/bin/keyston* /etc/nova /usr/local/bin/nova* /etc/neutron /usr/local/bin/neutron* /etc/glance /usr/local/bin/glance* /etc/cinder /usr/local/bin/cinder* /etc/heat
	;;
    esac
}
function ksInfo()
{   # shows usefull info about unknonw command provided as argument
    local cmd_name=$1
    local cmd_full_path=`which ${cmd_name}`
    file ${cmd_full_path}
    dpkg -S ${cmd_full_path}
}
WaasSocketFile="/tmp/WAAS"
WaasTunelPort="11111"
WaasRemoteDir="kshileev@localhost:/work/kshileev/tahoe"
WaasTbMsk1Edge='172.18.6.40'
WaasTbMsk1Core='172.18.6.41'

function ksWaasGoTbPod9
{
    local ClientPort=22131
    local ServerPort=22134
    local ClientIp=172.23.142.133
    local ServerIp=172.23.142.138
    local EdgeIp=2.75.57.162
    local CoreIp=2.75.57.34

    ssh -N -f -L ${ClientPort}:${ClientIp}:3389 kshileev@xe-kite.cisco.com
    ssh -N -f -L ${ServerPort}:${ServerIp}:3389 kshileev@xe-kite.cisco.com
    rdesktop -u Administrator -p watchThis  -T WinServer -g 1024x768 localhost:${ClientPort}  &
    rdesktop -u Administrator -p watchThis  -T WinClient -g 1024x768 localhost:${ServerPort}  &


    xterm -geometry 140x36+1600+10 -bg steelblue -fg black \
        -title "EDGE conf log disk pri not" \
        -e ssh -S ${WaasSocketFile} kshileev@localhost telnet ${EdgeIp} &

    xterm -geometry 140x36-900-10  -bg lightblue -fg black \
        -title "EDGE-DBG sh conn stat" \
        -e ssh -S ${WaasSocketFile} kshileev@localhost telnet ${EdgeIp} &

    xterm -geometry 130x36-5+10 -bg lightyellow   -fg black \
        -title "CORE (no) acc smb ena" \
        -e ssh -S ${WaasSocketFile} kshileev@localhost telnet ${CoreIp} &

    xterm -geometry 130x36-5-10 -bg black         -fg white -title LOCAL &
}
function WaasSocket
{
    if [ ! -S ${WaasSocketFile} ]; then
	echo "Creating file_socket to Cisco BLD server..."
	ssh -f -N -L ${WaasTunelPort}:adbu-bldsrv-03.cisco.com:22 kshileev@xe-kite.cisco.com
	ssh -f -N -p ${WaasTunelPort} kshileev@localhost -M -S ${WaasSocketFile}
    fi
}

WaasExcludeList="--exclude=CiscoInclude --exclude=ExternalMock.cpp --exclude=utils --exclude=.CC --exclude=.ACME --exclude=.#* --exclude=*.da --exclude=*.bb* --exclude=.hg* --exclude=.*project --exclude=Ut --exclude=Dbg --exclude=Lib --exclude=mock --exclude=gui --exclude=uml --exclude=.settings --exclude=Makefile* --exclude=Doxy-* --exclude=*.bm"

function ksWaasSyncDown
{
    if [ -d src -a -d ut -a -d include ]; then
	WaasSocket #establish tunnel to CISCO network
	local From=${WaasRemoteDir}/ao/smb/
	echo "Syncing down CISCO->LOCAL  from $From to .:"
	rsync -avz -e "ssh -S $WaasSocketFile" ${WaasExcludeList} --delete ${From} .
	echo "Finished."
    else
	echo  "Current directory must contain <include> <src> <ut>, aborting."
    fi
}
function ksWaasSyncUp
{
    if [ -d src -a -d ut -a -d include ]; then
	WaasSocket #establish tunnel to CISCO network
        local To=${WaasRemoteDir}/ao/smb
	echo "Doing LOCAL->WAAS from . to $To:"
        rsync -avz -e "ssh -S $WaasSocketFile" ${WaasExcludeList} --delete . ${To}
	echo "Finished."
    else
	echo "Current directory must contain <include> <src> <ut>, aborting."
    fi
}
function ksWaasGetRef
{
    WaasSocket #establish tunnel to CISCO network
    local Shell=${WaasRemoteDir}/ao/shell
    local Doc=${WaasRemoteDir}/derived/doc
    echo "$Shell -> .:"
    rsync -avz -e "ssh -S $WaasSocketFile" --exclude=.CC --exclude=.ACME --delete ${Shell} .
    echo "$Doc -> .:"
    rsync -avz -e "ssh -S $WaasSocketFile" --exclude=.CC --exclude=.ACME --delete ${Doc} .
    echo "Finished."
}
function ksWaasDeploySmb
{
    WaasSocket
    #local Dir=`mktemp -p /tmp -d WaasDeploySmb.XXXXXXXXXX`
    local WaasTmpDir=/tmp/WaasSmbDeploy
    mkdir -p ${WaasTmpDir}

    echo "Getting SMBAO executables ${WaasRemoteDir} ->  ${WaasTmpDir}:"
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/derived/unicorn/bin/smbao ${WaasTmpDir}
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/derived/unicorn/lib/libsmbao.so ${WaasTmpDir}
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/x86_64-derived/unicorn/bin/smbao ${WaasTmpDir}/smbao64
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/x86_64-derived/unicorn/lib/libsmbao.so ${WaasTmpDir}/libsmbao64.so
    cat >  ${WaasTmpDir}/deploy_smb <<EOF

function Deploy
{
    local Main=\$PWD
    local AfterRuby="/sw/unicorn/which.variant"
    local Variant

    ls -d /local/local1/kshileev/*/
    read -p 'Choose variant: ' Variant
    [ -z \$Variant ] && echo Nothing choosen, exiting && return

    mount -o remount,rw /sw

    if [ ! -f \$AfterRuby ]; then
	echo "Running first time after ruby redeployment, saving ruby variant"
        mkdir -p \$Main/ruby
        cp /sw/unicorn/bin/smbao64 \$Main/ruby/smbao64
        cp /sw/unicorn/bin/smbao   \$Main/ruby/smbao
        cp /sw/unicorn/lib/libsmbao.so   \$Main/ruby/libsmbao.so
        cp /sw/unicorn/lib64/libsmbao.so   \$Main/ruby/libsmbao64.so
    fi

    echo Deploying \$Variant
    cp \$Variant/smbao         /sw/unicorn/bin/smbao64
    cp \$Variant/libsmbao.so   /sw/unicorn/lib/libsmbao.so
    cp \$Variant/libsmbao64.so /sw/unicorn/lib64/libsmbao.so
    echo \$Variant > \$AfterRuby
}

Deploy
tail -f ~/errorlog/smbao-errorlog.current
EOF
    cat > ${WaasTmpDir}/ps1 <<EOF
export PS1="\!:\W> "
alias k='cd /local/local1/kshileev'
alias v='cat /sw/unicorn/which.variant'
EOF
    chmod +x ${WaasTmpDir}/deploy_smb
    echo Deploying on edge ${WaasTbMsk1Edge} ....
    sshpass -p default ssh admin@${WaasTbMsk1Edge} mkdir kshileev
    sshpass -p default ssh admin@${WaasTbMsk1Edge} mkdir kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/*smbao* admin@${WaasTbMsk1Edge}:kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/deploy_smb admin@${WaasTbMsk1Edge}:kshileev/
    sshpass -p default scp ${WaasTmpDir}/ps1 admin@${WaasTbMsk1Edge}:kshileev/
    echo Deploying on core ${WaasTbMsk1Core} ....
    sshpass -p default ssh admin@${WaasTbMsk1Core} mkdir kshileev
    sshpass -p default ssh admin@${WaasTbMsk1Core} mkdir kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/*smbao* admin@${WaasTbMsk1Core}:kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/deploy_smb admin@${WaasTbMsk1Core}:kshileev/
    sshpass -p default scp ${WaasTmpDir}/ps1 admin@${WaasTbMsk1Core}:kshileev/
    rm -rf ${WaasTmpDir}
    echo "Finished."
}
function ksWaasDeployRuby
{
    WaasSocket
    local RubyName=ruby.$(date +%Y-%m-%d)
    echo "Getting $RubyName:"
    scp -P ${WaasTunelPort} ${WaasRemoteDir}/derived/ruby.bin /var/www/${RubyName}
    echo "Executing EDGE reload" && sshpass -p default ssh admin@edge copy http install kshileev-lnx / ${RubyName}
    sshpass -p default ssh admin@edge reload force
    echo "Executing CORE reload" && sshpass -p default ssh admin@core copy http install kshileev-lnx / ${RubyName}
    sshpass -p default ssh admin@core reload force
}
function ksHgRepo
{
    WaasSocket
    local Dir=~/mercurial
    if [ ! -d ${Dir} ]; then
        echo "Clone Mercurial WaaS repo to ${Dir}: (Provide GD LDAP credetianls)"
        hg clone http://cisco-mercurial.griddynamics.net/hg/SMB_AO_Prototypes ${Dir}
        cat > ${Dir}/.hg/hgrc <<EOF
[paths]
default = ssh://kshileev@localhost:11111//work/gdemchen/smbao
[ui]
username = Kirill Shileev<kshileev@cisco.com>
EOF
    else
        echo Mercurial repo is already cloned to ${Dir}
    fi
}
function ksGo
{
    local dest=$(ksGetChoice 'TOR231 EvGen229 EvGen230 232')
    case ${dest} in
	TOR231) sshpass -p c3l12345 ssh openstack-read@172.29.172.140 ;;
	EvGen229) sshpass -p ubuntu ssh localadmin@172.29.173.229 ;;
	EvGen230) sshpass -p ubuntu ssh localadmin@172.29.173.230 ;;
	232) sshpass -p ubuntu ssh localadmin@172.29.173.232 ;;
    esac
}
function ksRepo
{
    local repo=$(ksGetChoice 'rally devstack tempest cisco-networking cisco-sqe cisco-kloudbuster barracuda ovzctl ovzkernel')
    case ${repo} in
	rally) git clone https://git.openstack.org/openstack/rally;;
	devstack) git clone https://github.com/openstack-dev/devstack.git;;
	tempest) git clone https://github.com/openstack/tempest.git;;
	cisco-sqe) git clone https://github.com/cisco-openstack/openstack-sqe.git sqe;;
	cisco-kloudbuster) git clone https://github.com/openstack/kloudbuster.git kloud;;
        cisco-networking) https://git.openstack.org/openstack/networking-cisco netcis;;
	barracuda) git clone git@github.com:kshileev/barracuda.git $HOME/barr ;;
	ovzctl) git clone git://git.openvz.org/pub/vzctl $HOME/vz/ovzctl ;;
	ovzkernel) git clone git://git.openvz.org/pub/linux-2.6.18-openvz $HOME/vz/18-ovz ;;
	my) git clone git@github.com:kshileev/my.git ;;
    esac
}
function ksInitrd
{
    echo Operations with INITRD:
    echo 1. unzip into current dir
    echo 2. zip current dir into ~/initrd-${USER}.img
    # read -p gzip -dc | cpio -i > .
    #find . | cpio -co --quiet | gzip -c > ~/initrd.img'
    ls *initrd* /boot/initrd*
    local IrdName=$(ksGetInput 'Choose initrd image:')
    rm -rf $HOME/ird
    mkdir -p $HOME/ird
    cp ${IrdName} $HOME/ird/tmp-initrd
    cd $HOME/ird
    gzip -dc tmp-initrd | cpio -id
    rm tmp-initrd
}
function ksBootOnce
{
    echo Configure grub to boot just once
    echo "savedefault --default=0 --once" |grub
}
function ksCscopePrepare
{
    local what=$(ksGetChoice 'devstack c-proj')
    echo Preparing CSCOPE to browse in $PWD
    mkdir -p ${MY_CSCOPE_DIR}
    case ${what} in
	devstack) find ${PWD} -name stack.sh -o -name functions -o -name neutron > ${MY_CSCOPE_FILE_LIST} && cd ${MY_CSCOPE_DIR} && cscope -b -q && cd -
	    ;;
	c-proj)   find ${PWD} -name "*.[ch]" -o -name "*.[ch]pp" | grep -v ut/ | grep -v utils/ > ${MY_CSCOPE_FILE_LIST} && cd ${MY_CSCOPE_DIR} && cscope -b -q -k && cd -
	    cscope -b -q -k
	    ;;
    esac
}
function ksAliasDefine()
{
    echo Defines aliases
    alias a='alias'
    alias ar='. ~/VE/rally/bin/activate'
    alias cdm="cd ${MY_DIR}"
    alias cdt="cd /opt/stack/tempest"
    alias df='df -h'
    alias dm='dmesg'
    alias di="gendiff . .${MY_USER} > ~/${MY_USER}.diff-xx-xxxx-`date +%Y%m%d`"
    alias du='du -h'
    alias e='echo'
    alias ee="vim ${MY_BASH_RC}"
    alias fk="find . -name \"*.${MY_USER}\""
    alias gb='git branch -vv'
    alias gc='git checkout -- .'
    alias gd='git diff'
    alias gf='git fetch'
    alias gl='git log'
    alias gp='git pull'
    alias gr='git remote -v'
    alias gs='git status'
    alias grc='find . -name "*.[ch]pp" -o -name "*.[ch]" | xargs grep'
    alias h='history'
    alias i='python setup.py install'
    alias l='ls -F --color=tty'
    alias l.='ls -dh .* --color=auto'
    alias ll='ls -Flih --color=auto'
    alias ll.='ls -Fldih .* --color=auto'
    alias ld='ls -lad --color=auto'
    alias ls='ls --color=auto'
    alias m='less'
    alias p="pstree -h"
    alias py="ipython"
    alias pss='ksShowProcess'
    alias pt="patch -p1 -b -z .${USER}"
    alias pw="ps uxwf"
    alias q='. ~/buzzoola/deploy/provision.sh'
    alias src=". ${MY_BASH_RC}"
    alias sslt='ps auxw |grep ssh |grep -v grep'
    alias s='ssh -o StrictHostKeyChecking=no'
    alias u='cd ..'
    alias v='ksVirtStatus'
    alias ve='ksVirtualEnv'

    #alias   0m64='make -j32 CC=distcc ARCH=x86_64'
    #alias   0mod="gcc -c -Wall -nostdinc -I/usr/src/linux/include"
    #alias   0RpmBld32='rpmbuild --nodeps --target=i386 --define "_sourcedir $PWD" --define "_builddir $HOME/bld"'
    #alias   0RpmBld64='rpmbuild --nodeps --target=x86_64 --define "_sourcedir $PWD" --define "_builddir $HOME/bld"'
    #alias   0RpmBld='rpmbuild --define "_sourcedir $PWD" --define "_builddir $PWD" --define "_rpmdir $HOME"'
    #alias   0vztc='echo "BASE<<4+1"; cat /var/run/vz_tc_base; cat /var/run/vz_tc_classes; tc filter show dev eth0 parent 2:'
    #alias   0vzl='vzlist -a -o ctid,hostname,ip,numproc,ostemplate'
    #alias   0vzst='vzctl set 101 --hostname changename '
#    alias   0gos='sshpass -p girl:click.bravo ssh -R 7777:localhost:22 russup@support.swsoft'
#    alias   0gred='sshpass -p 1q2w3e ssh kir@red.dragon.gdc.mirantis.sar'
#    alias   0gblu='sshpass -p 1q2w3e ssh kir@blue.dragon.gdc.mirantis.sar'
    alias dsd='cd ~/devstack && git checkout 905275ec9f51614911fbb915f8bba9896b3ab684'
}
function ksKirGrep
{
    [ -z "$1" ] && echo Usage $FUNCNAME symbol || echo $1 a\is in :
    find . -name *.[ch]pp | xargs grep $1
}
function ksSizeOf
{
	if [ "$#" == "0" ]; then
		echo Usage: $0 c1i1
		return
	fi

	for c in $1 ;  do
		echo ${c}
	done

	Class="class Class{char c; int i;};" #

	local TmpCode=$(mktemp -u).c++ #tmp file of type /tmp/tmp.XXXXXXXX.c++ -u: don't create it (unsafe)
	local TmpBin=${TmpCode/c++/exe}

	cat > ${TmpCode} <<EOF
#include <iostream>
using namespace std;

${Class}

int main()
{
	Class obj;
	cout<<"${Class} CLS="<<sizeof(Class)<<" obj="<<sizeof(obj)<<endl;
	return 0;
}
EOF

	g++ ${TmpCode} -o ${TmpBin}
	echo Platform `uname -m`
	${TmpBin}
	rm ${TmpCode} ${TmpBin}
}
function ksDhcpd
{
	[ -f /etc/dhcpd.conf ] && ConfFile=/etc/dhcpd.conf
	cat > ${ConfFile} << EOF
authoritative;
option domain-name "barracuda";
option domain-name-servers 192.168.4.1;

subnet 10.0.0.0 netmask 255.255.255.0 {
  option routers  10.0.0.1;

  pool {
    range dynamic-bootp  10.0.0.20 10.0.0.250;
    default-lease-time 86400;
    max-lease-time 86400;
  }

  next-server 10.0.0.10;
  filename "pxelinux.0";
}
EOF
}
function ksGenClass
{
    local Class=$(ksGetInput 'Class name' 'KirClass')
    local Base=$(ksGetInput 'Base name' 'KirBase')
    local Ext=$(ksGetInput 'C++ extention' '.c++')
    File=${Class}${Ext}
    Header=${Class}.h

    cat > ${Header} <<EOF
#ifndef ${Class}_h"
#define ${Class}_h"

#include <$Base.h>

class ${Class} : public ${Base}
{
public:
    ${Class}();
   ~${Class}();
protected:
  ClassDef(${Class},0)
};//class ${Class}
#endif//${Class}_h
EOF

	cat > ${File} << EOF
#include \"$Header\""             >>$File;                       echo >>$File
ClassImp(${Class})"                 >>${File};                       echo >>${File}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >>${File}
${Class}::${Class}()"                 >>${File}
{//ctor
  PrintDebugStart(\"ctor\");"     >>${File}
  PrintDebugStop(\"ctor\");"      >>${File}
  return;"                        >>${File}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
${Class}::~${Class}()
{//dtor
  PrintDebugStart("dtor");
  PrintDebugStop("dtor");
  return;
}
EOF
}
function PingNode
{
   ping -c 1 $1 > /dev/null 2>&1
   [ "$?" == "0" ] ||  echo Node \"$1\" is off, aborting...
}
function ksMyEnvDeploy()
{
    local my_env_command=$(ksGetChoice 'local remote update' $1)
    case ${my_env_command} in
    local)
        ksAddLineToFileIfNotThere "[ -f ${MY_BASH_RC} ] && . ${MY_BASH_RC}" ~/.bashrc
	[ ! -L ~/.vimrc ] && mv  ~/.vimrc ~/VimRcToCheck
	[ -L ~/.vimrc ] || ln -s ${MY_VIM_RC} ~/.vimrc
	;;
    remote)
	grep -v ^127 /etc/hosts | grep ^[1-2]
	local Node=$(ksGetInput 'Choose node where to deploy' 'NoNode')
	echo "Deploing to ${Node}:"
	scp -p ${MY_BASH_RC} ~/.bash_profile ${MY_VIM_RC} localadmin@${Node}:
	;;
    update)
	cd ${MY_DIR}
	git pull
	;;
    esac
}
function ksCheckOs
{ # we're running on deb based or rpm based OS?
  local deb=/etc/debian_version
  local rpm=/etc/redhat-release
  [ -f ${deb} ] && { echo -n "It's DEBIAN version: " ; cat ${deb}; return 1; }
  [ -f ${rpm} ] && { echo -n "It's RPM version: "    ; cat ${rpm}; return -1; }
}
function ksBuildDisketteRouter
{
# Created 05.07.2003
# Used materials:
# Linux kernel doc ramdisk.txt usually found in /usr/src/linux/Documentation

	Tar=`pwd`
	Size=4096
	Tmp=/mnt/router #where to create all the disket staff, currently directly on floppy disk
	Device=/dev/ram

	if [ ! -f ${Tar}/etc/rc.router ]; then
		echo "No $Tar file"
	exit -1
	fi

	echo "Coping linux kernel..."
	dd if=/usr/src/linux/arch/i386/boot/bzImage of=/dev/fd0 bs=1k
	echo "Force kernel to use diskette as root device"
	rdev /dev/fd0 /dev/fd0
	echo "Tell kernel where to find compressed ramdisk"
	rdev -r /dev/fd0 16984

	echo "Cleaning $Size kb of $Device..."
	dd if=/dev/zero of=${Device} bs=1k count=${Size}

	echo "Creating ram disk of $Size kb and mounting it in $Tmp..."
	[ -d ${Tmp} ] || mkdir ${Tmp}
	mke2fs -m0 ${Device} ${Size} >/dev/null 2>&1
	mount ${Device} ${Tmp}

	echo "Creating ramdisk structure in $Tmp..."
	cd ${Tar}
	cp -r * ${Tmp}

	echo "Creating dev substructure in $Tmp..."
	mknod ${Tmp}/dev/console c 5 1
	#mknod $Tmp/dev/ramdisk b 1 0

	echo "Unmounting and deleting $Tmp..."
	umount ${Tmp}
	rm -rf ${Tmp}

	echo "Creating compressed ramdisk image on diskette from $Tmp..."
	dd if=${Device} bs=1k | gzip -v9 | dd of=/dev/fd0 bs=1k seek=600
}
function cat_files()
{
	local dir=$1
	local files=$2
	for f in ${files}; do
		echo -e "\n$dir/$f:"
		cat ${dir}/${f}
		echo -e "<----\tend\t----"
	done
}
function ksAfsStatus()
{
	service openafs-server status
	service openafs-client status
	echo -e "\n\n**\t**\tSTATUS:\t**\t**\n"
	echo ++++++++++++++++++++Server:
	ls -F "/usr/afs/{etc,db,logs,local}*";	files='ThisCell CellServDB';	cat_files /usr/afs/etc ${files}
					files='BosConfig';		cat_files /usr/afs/local ${files}
	echo ++++++++++++++++++++Client:
	ls -F /usr/vice/*; files='ThisCell CellServDB.local cacheinfo'; cat_files /usr/vice/etc ${files}

	echo +++++++++++++++++++/vicepa:
	ls -F /vicepa/

	echo -e "**\t**\tFINISHED\t**\t**"
	#echo BOS status:;	bos status localhost -localauth
	#echo BOS users:;	bos listusers localhost -localauth
	#echo BOS hosts:;	bos listhosts localhost -localauth
	#echo BOS keys:;	bos listkeys localhost -localauth
	echo asetkey:;		asetkey list
	#echo VOS volumes:;	vos listvol localhost -localauth
}
function PingNodeOrExit()
{
   ping -c 1 $1 > /dev/null 2>&1
   [ "$?" == "0" ] || { echo Node \"$1\" is off, aborting...; exit 1; }
}
function ksIntallKernel2Remote
{
    grep "Linux kernel release" README >/dev/null 2>&1
    [ $? -ne 0 ] && echo You need to invoke this from head of kernel tree && return 1
    echo Install new kernel
    ls configs/
    local Node=$(ksGetInput 'remote node name' 'tom')
    PingNodeOrExit ${Node}
    local Arch=$(ksGetChoice 'x86_64 i386')
    local Conf=$(ksGetChoice '.config')
    [ -z "$Conf" ] || cp configs/${Conf} .config
    make ARCH=${Arch} nonint_oldconfig   ; [ "$?" != "0" ] && return 1
    make ARCH=${Arch}                    ; [ "$?" != "0" ] && return 1

    Release=$(make kernelversion)

    Dir=$HOME/tmp ;    mkdir -p ${Dir} ;    mkdir -p ${Dir}/boot
    INSTALL_MOD_PATH=${Dir} make modules_install
                      cp arch/${Arch}/boot/bzImage  ${Dir}/boot/vmlinuz-${Release}
                      cp System.map               ${Dir}/boot/System.map-${Release}
    chmod -x vmlinux; cp vmlinux                  ${Dir}/boot/vmlinux-${Release}
                      cp .config                  ${Dir}/boot/config-${Release}

    Tarball=$HOME/tst-kernel-${Release}.tgz
    cd ${Dir} ; tar czf ${Tarball} * ;  scp ${Tarball} root@${Node}:/ ;  rm -rf ${Dir} ${Tarball}
}
function ksOvzNewCt
{
  echo "OS templates, currently installed:"
  vzpkg list
  vzpkgls
  local NumCt=$(ksGetInput 'How many CTs' '1')
  local Ostmpl=$(ksGetInput 'Which OS template')
  [ "$NumCt" == "1" ] && names="241"
  [ "$NumCt" == "2" ] && names="241 242"
  [ "$NumCt" == "3" ] && names="241 242 243"
  [ "$NumCt" == "4" ] && names="241 242 243 244"
  [ "$NumCt" == "5" ] && names="241 242 243 244 245"
  for ctid in ${names}; do
    cthn=k${ctid}.ct
    ctip=10.0.15.${ctid}
    vzctl create ${ctid} --ostemplate ${OsTmpl}
    vzctl set ${ctid} --ipadd ${ctip} --hostname ${cthn} --userpasswd root:1q2w3e --save
    vzctl start ${ctid}
  done
}
function ksRefRus {
    cat  <<EOF
Это русский текст в кодировке UTF8
Ё!"№;%:?*()_+/
ё1234567890-=\

??? ????? ? ????????? KOI8R
?!"#*:,.;()_+| ?
?1234567890-=\ /

??? ⥪?? ? ????஢?? CP866
?!"#*:,.;()_+| ?
?1234567890-=\ /

??? ????? ? ????????? CP1251
?!"#*:,.;()_+| ?
?1234567890-=\ /
EOF
}
function ksRefMorze {
    cat <<EOF
01 Aa ._   alfa     А   01 А .-    ай-даа            A          alpha
02 Bb -... bravo    Б   02 Б -...  баа-ки-те-кут     B          beta
03 Cc -.-. charlie  Ц   03 В  .--  ви-даа-лаа        W          gamma
04 Dd -..  delta    Д   04 Г  --.  гоо-воо-ри        G          delta
05 Ee .    echo     Е   05 Д  -..  доо-ми-ки         D          epsilon
06 Ff ..-. foxtrot  Ф   06 Е  .    есть              E          zeta
07 Gg --.  golf     Г   07 Ё                                    eta
08 Hh .... hotel    Х   08 Ж  ...- жи-ви-те-стоо     V          theta
09 Ii ..   india    И   09 З  --.. заа-каа-ти-ки     Z          iota
10 Jj .--- juliett  Й   10 И  ..   и-ди              I          kappa
11 Kk -.-  kilo     К   11 Й  .--- ку-даа-поо-шлаа   J          lambda
12 Ll .-.. lima     Л   12 К  -.-  каак-де-лаа       K          mu
13 Mm --   mike     М   13 Л  .-.. лу-наа-ти-ки      L          nu
14 Nn -.   november Н   14 М  --   маа-маа           M          xi
15 Oo ---  oskar    О   15 Н  -.   ноо-мер           N          omicron
16 Pp .--. papa     П   16 О  ---  оо-коо-лоо        O          pi
17 Qq --.- quebec   Щ   17 П  .--. пи-лаа-поо-ёт     P          rho
18 Rr .-.  romeo    Р   18 Р  .-.  ре-шаа-ет         R          sigma
19 Ss ...  sierra   С   19 С  ...  са-мо-лёт         S          tau
20 Tt -    tango    Т   20 Т  -    таак              T          upsilon
21 Uu ..-  uniform  У   21 У  ..-  у-нес-лаа         U          fi
22 Vv ...- victor   Ж   22 Ф  ..-. фи-ли-моон-чик    F          chi
23 Ww .--  whiskey  В   23 Х  .... хи-ми-чи-те       H          psi
24 Xx -..- x-ray    Ь   24 Ц  -.-. цаа-пли-цаа-пли   C          omega
25 Yy -.-- yankee   Ы   25 Ч
26 Zz --.. zulu     З   26 Ы  -.-- ыы-не-наа-доо     Y
                        27 Ш  ---- шаа-роо-ваа-рыы
                        28 Щ  --.- щаа-ваам-не-шаа   Q
                        29 Ь  -..- тоо-мяг-кий-знаак X
                        30 Ъ
                        31 Э  ..-..э-ле-роон-чи-ки
                        32 Ю  ..-- ю-ли-аа-наа
                        33 Я  .-.- я-маал-я-маал
EOF
}
function ksRefHex
{
    cat <<EOF
 hex table:
 0 0x0 0000
 1 0x1 0001
 2 0x2 0010
 3 0x3 0011
 4 0x4 0100
 5 0x5 0101
 6 0x6 0110
 7 0x7 0111
 8 0x8 1000
 9 0x9 1001
10 0xa 1010
11 0xb 1011
12 0xc 1100
13 0xd 1101
14 0xe 1110
15 0xf 1111
EOF
}
function ksRefRpm {
   cat <<EOF
list all packages  rpm -qa                   dpkg -l
list files         rpm -ql name              dpkg -L name
show info          rpm -qi name              dpkg -s name
who owns the file  rpm -qf file              dpkg -S file
show scripts       rpm -q --scripts name     cat /var/lib/dpkg/info name.xxx
install package    rpm -ivh name             dpkg --force-architecture -i name
verify package     rpm -V name               dpkg -V name
key install        rpm --import key
show key ring      rpm -qa gpg-pubkey*
EOF
}
function ksRefNet {
cat <<EOF
route add -host 10.20.30.40 gw vas1

sudo ip l a <if-name> type dummy			#add interfece
sudo ip l a link eth0 name eth0.2 type vlan id 2 loose_binding on
sudo ip l s <if-name> up				#switch on interface
sudo ip l d <if-name>					#delete interface
sudo ip l s <if-name> promisc on			#switch off promisc
sudo ip l s <if-name> promisc off			#switch off promisc

sudo ip -6 a a 2005:1975::1/64 dev eth0			#add v6 address to iface
sudo ip -6 a d 2005:1969::1/64 dev eth0			#remove v6 address from iface

sudo ip r a 10.0.15.0/28 via 10.30.1.180
sudo ip r a 10.0.5.1 dev vlan105
sudo ip r c default via 10.20.30.40 dev eth0		#change default route

sudo ip net d <ns_name>					#delete namespace

sudo brctl addif br105 vlan105

sudo virsh net-list
sudo virsh net-destroy net_name
sudo virsh net-undefine net_name

sudo ovs-vsvtl show
sudo ovs-vsctl del-br <bridge_name>

net:  Fedora                                       Ubuntu
      /etc/sysconfig/network-scripts/ifcfg-eth0    /etc/network/interfaces

sudo ettercap -C -i eth0                 # start listening with on eth0
sudo tcpdump -vv -n -t -i eth0 -c 10     #
sshpass -p default ssh admin@172.18.6.40 # go to node with password default


tcpdump -i br0 -vvv -s 1500 '((port 67 or port 68) and (udp[8:1] = 0x1))'  # dhcp DISCOVER REQUEST INFORM
sudo tcpdump -n -i br0 -vvv icmp6 # v6 neighbours solicitation and advertisiment
EOF
}
function ksRefRe {
cat <<EOF
find $HOME bar foe -name *.c[   # find all files *.c and *. in ~ bar and foe dirs
grep -E "foo|bar"		# find foo or grep
EOF
}
function ksRef {
   cat <<EOF
mount -o rw,remount /dev/sda1
echo CONFIG_DEBUG_IN=y > .config ; make oldconfig #build with debug
make -j32 CC=distcc ARCH=x86_64                   #build with DISTCC
make V=1                                          #build with verbose printout
echo "savedefault --default=1 --once" |grub #say grub to reboot once
echo kernel XXXX ro root=LABEL=/ debug oops=panic panic=1 console=ttyS0,115200 console=tty > /boot/grub/menu.lst #reboot if panic
syscall:	check include/asm/unistd.h for __NR_syscallname

cscope -b -R          # build reference file
cscope -b -q -k       # used

watch -d -n 5 ip a    # re-run ip a every 5 secs and highlight difference

ps -L -p pid # shows all threads for process

diff -pNU7 # p for function N
EOF
}
function ksRefBash() {
    cat <<EOF
for _ in \`some_cmd\`; do echo _ ; done
while true ; do echo 123 ; done # busy cycle
[[ -n \${tmp} ]] && echo OK   # execute if len(tmp) is not 0
[[ 'aa bb' != *aa* ]] && echo ok
EOF
}
function ksRefPuppet {
   cat <<EOF
git clone https://github.com/CiscoSystems/puppet_openstack_builder
cd puppet_openstack_builder
git checkout icehouse
cd install-scripts
export build_server_ip=<YOUR_BUILD_NODE_IP>
bash setup.sh
puppet aggent -td --server=build-server.domain.name --pluginsync
EOF
}
function ksRefOS
{
cat <<EOF
mysql --user=nova --password=nova nova
select id,cidr,project_id  from networks;

nova keypair-add --pub-key ~/.ssh/id_rsa.pub vaio
neutron security-group-rule-create --protocol icmp --ethertype=IPv6 --direction ingress default
neutron security-group-rule-create --protocol tcp --ethertype=IPv6 --direction ingress --port-range-min 22 --port-range-max 22 default

neutron net-list
neutron net-create ext46 --router:external --shared
neutron net-delete ext46
neutron subnet-list
neutron subnet-create ext46 10.100.0.0/16 --name=sub4
neutron subnet-create ext46 2001:db8:10::/64 --ip-version=6 --name=slaac6 --ipv6-ra-mode=slaac --ipv6-address-mod=slaac
neutron subnet-create ext46 2001:db8:20::/64 --ip-version=6 --name=stateless6 --ipv6-ra-mode=dhcpv6-stateless --ipv6-address-mod=dhcpv6-stateless
neutron subnet-create ext46 2001:db8:30::/64 --ip-version=6 --name=stateful6 --ipv6-ra-mode=dhcpv6-stateful --ipv6-address-mod=dhcpv6-stateful

neutron router-create r46
neutron router-gateway-set r46 ext46
neutron router-interface-add r6 sub6

nova boot i1 --flavor=1 --image=20e68825-3d8b-4d5c-ac84-17f1101ec643 --nic net-id=aacf221a-f348-4909-9b86-55a38b369859
nova delete i1
EOF
}
function ksRefVim
{
  cat << EOF
vim "+e ++enc=utf8" #run vim with russian support (cp1251 utf8  koi8r cp866)
open file under cursor:\t gf <C-w>f <C-w>gf in new tab
go forth and back:\t <C-]> <C-T> <C-O>
substitute:\t :%s/pattert/string/cg
EOF
}
function ksTailLogAfs
{
    cd /var/log
    if ksCheckOs; then
	tail -F daemon.log user.log autgh.log debug kern.log dmesg messages \
	    kerveros/krb5kdc.log kerveros/kadmin.log kerveros/krb2lib.log \
	    openafs/BosLog openafs/FileLog openafs/SalvageLog openafs/VLLog openafs/VolserLog
    else
	tail -F messages yum.log kadmin.log krb2kdc.log krb5libs.log /usr/afs/logs/*Log	
    fi
}
function ksNtpCreateConfig
{
    cat > /etc/ntp.conf <<EOF
driftfile /var/lib/ntp/drift

restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery

restrict 127.0.0.1 
restrict -6 ::1

server dn11.kirshil.ru

includefile /etc/ntp/crypto/pw

keys /etc/ntp/keys
EOF
}
function ksTcpDump
{
    local tcpdump_command=${1:-$(ksGetChoice 'dhcp')}
    case ${tcpdump_command} in
    dhcp)
	sudo tcpdump -i any -vvv -s 1500 '((port 67 or port 68) and (udp[8:1] = 0x1))'
    ;;
    esac
}
function sk_deploy_key_pair()
{ # Check that ssh private-public is indeed a pair and deploy them to the given server
    local what_to_deploy=$1
    local private=$2
    local server=$3
    local user=$4
    local password=$5

    if [[ ${what_to_deploy} == "-h" ]]; then
	echo "Usage: $0 [public|private] priv_key_path host user password"
	return
    fi
    [[ -z ${what_to_deploy} ]] && what_to_deploy=public
    [[ -z ${private} ]] && private=${MY_DIR}/keys/kir_no_secret
    [[ -z ${server} ]] && server=localhost
    [[ -z ${user} ]] && user=localadmin
    [[ -z ${password} ]] && password=ubuntu

    local public=${private}.pub
    local fingerprint=$(ssh-keygen -lf ${private})
    local public_value=$(cat ${public})
    local private_value=$(cat ${private})
    local public_value_from_private=$(ssh-keygen -yf ${private})

    if [[ ${public_value} = ${public_value_from_private}* ]]; then
	echo "${public} -> ${fingerprint}"
	case ${what_to_deploy} in
	    private)
		sshpass -p ${password} scp ${private} ${user}@${server}:~/.ssh/id_rsa
	    ;&
	    public)
		sshpass -p ${password} ssh ${user}@${server} echo ${public_value} >> ~/.ssh/authorized_keys
	    ;;
	esac
    else
	echo "${private} and ${public} are not a match!"
    fi
}
function ksSshKey
{ # manipulate with ssh keys
    local ssh_command=${1:-$(ksGetChoice 'pair-ssh add-public add-private pair-cert fingerprint')}
    case ${ssh_command} in
    add-public-local)
        mkdir -p ~/.ssh
        [ -f ~/.ssh/authorized_keys ] || touch ~/.ssh/authorized_keys
        [ -z "$(grep "${kir_vaio_pub}" ~/.ssh/authorized_keys)" ] && echo ${kir_vaio_pub} >> ~/.ssh/authorized_keys
        echo "KirVaio public key is added"
    ;;
    add-private)
	[ -z "$SSH_AGENT_PID" ] && echo ssh-agent not running. &&  return 1
        echo Currently loaded keys:
        ssh-add -l
        echo Currently available :
	local prv_keys=$(find $HOME -name *.pk)
	local prv_key=$(ksGetChoice $(prv_keys))
        [ -f ${prv_key} ] && ssh-add ${prv_key}
	;;
    pair-cert)
	echo Operations with p12 and pem public-private pairs
        ls ${MY}/keys/* ${HOME}/.ssh/*
	local Public=$(ksGetInput 'Public  key'); [[ -z $Public ]] && return
	local Private=$(ksGetInput 'Private  key'); [[ -z $Private ]] && return

        local out1=$(openssl rsa -in ${Private} -noout -modulus)
        local out2=$(openssl x509 -in ${Public} -noout -modulus)
        echo ${Public} and ${Private}
        [ "$out1" == "$out2" ] && echo "are pair" || echo "are NOT pair"
    ;;
    fingerprint)
        ls ${HOME}/.ssh/* ${MY_DIR}/keys/*
	local private=$(ksGetInput 'Which private key')
	[ -z "${private}"  ] && return
	sk_deploy_key_pair check ${private}
    ;;
    esac
}
function ksJenkins
{
    wget -q -O - http://pkg.jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -
    echo deb http://pkg.jenkins-ci.org/debian binary/ | sudo tee -a /etc/apt/sources.list
    sudo apt-get update
    sudo apt-get install jenkins
}
function ksShowProcess()
{
    local name=$1
    local pid=$2
    ps -C ${name} -o user,pid,ppid,cmd
    [[ -n ${pid} ]] && ps -p ${pid} -o user,pid,ppid,cmd
}
function ksVirtualEnv()
{
    ls ~/VE
    local venv=$(ksGetInput 'Choose venv'); [[ -z $venv ]] && return
    . ~/VE/${venv}/bin/activate
}
function ksKloudBuster()
{
    ls ~
    local cloud_rc=$(ksGetInput 'Choose cloud'); [[ -z $cloud_rc ]] && return
    cd ~/os/kloud/kloudbuster
    python kloudbuster.py --tested-rc ~/${cloud_rc} --tested-passwd admin --json ~/kloud.json
    python kb_gen_chart.py -c ~/kloud.html ~/kloud.json
    rm -f ~/kloud.json
}

ksAliasDefine
[ -f /etc/bash_completion ] && . /etc/bash_completion
