# Login interactive shell: /etc/bash then ~/.bash_profile
# Non-log shell: execute ~/.bashrc only
# Non-interactive shell: execute script pointed by $ENV, nothing if $ENV = ""
[ -z "PS1" ] && return					#nothing to do for non interactive shell
PS1="\W> "	    #prompt: hostname:dirname>

export PATH="$HOME:/usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin"
export MY_USER=kshileev
export MY_TMP_DIR=/tmp/${MY_USER}
export MY_VENV_DIR=${HOME}/venv
export MY_DIR=$(cd $(dirname "${BASH_SOURCE:-$0}") && pwd)
export MY_BASH_RC=${MY_DIR}/RcBash
export MY_VIM_RC=${MY_DIR}/RcVim
export SYSSCREENRC=${MY_DIR}/RcScreen
mkdir -p ${MY_TMP_DIR}
export MY_CSCOPE_DIR=${MY_TMP_DIR}/cscope		#tmp dir where cscope stores the output
export MY_CSCOPE_FILE_LIST=${MY_CSCOPE_DIR}/cscope.files	#file to list files to browse into db
export LESSHISTFILE=${MY_TMP_DIR}/LessHist
export HISTFILE=${MY_TMP_DIR}/BashHist
export HISTSIZE=5000
export HISTCONTROL=ignoreboth
export X509_USER_CERT=${MY}/KirINFN.pem		#certificate used by globus
export X509_USER_KEY=${MY}/KirPrivate.pem	#private key for this certificate
export SIMPLE_BACKUP_SUFFIX=.${MY_USER}		#used by patch to store initial state of touched files
export DISTCC_HOSTS='1.1.1.1 2.2.2.2 3.3.3.3'	#used by make -j
export ARTISTIC_STYLE_OPTIONS=${MY_DIR}/RcAstyle
export LD_LIBRARY_PATH=$HOME
export ROOTGUI=native
export TZ='Europe/Moscow'
ColorNormal="\\033[0;39m"
ColorBlack="\\033[0;30m";     ColorDarkGray="\\033[1;30m"
ColorBlue="\\033[0;34m";      ColorLightBlue="\\033[1;34m"
ColorGreen="\\033[0;32m";     ColorLightGreen="\\033[1;32m"
ColorCyan="\\033[0;36m";      ColorLightCyan="\\033[1;36m"
ColorRed="\\033[0;31m";       ColorLightRed="\\033[1;31m"
ColorPurple="\\033[0;35m";    ColorLightPurple="\\033[1;35m"
ColorBrown="\\033[0;33m";     ColorYellow="\\033[1;33m"
ColorLightGray="\\033[0;37m"; ColorWhite="\\033[1;37m"

setcolor_caption="echo -en \\033[1;34m"
setcolor_success="echo -en \\033[1;32m"
setcolor_failure="echo -en \\033[1;31m"
setcolor_normal="echo -en \\033[0;39m"

_ecount=0
function _e()
{
	_ecount=$((_ecount+1))
	${setcolor_caption}
	echo -n "Phase #$_ecount: $*..."
	${setcolor_normal}
	echo
}
function _eok()
{
	${setcolor_success}
	echo -n "DONE"
	${setcolor_normal}
	echo
}
function _enok()
{
	${setcolor_failure}
	echo -n "FAILED"
	${setcolor_normal}
	echo
}
function _section()
{
    printf "\n%-10s %0100s\n" $1
}
function _get_input()
{
    local commands=$1
    local command=$2
    [[ -n ${command} ]] && [[ ${commands} == *${command}* ]] && echo ${command} && return
    local default_command=$(echo ${commands} | cut -d ' ' -f1)
    local input
    read -p "choose from ${commands} [default=${default_command}]: " input
    [[ ${commands} != *${input}* ]] && echo Wrong command ${input} 1>&2 && return
    echo ${input:-${default_command}}
}
function ksPrintDevstackStatus()
{
    local log_file=`find ~/os /opt -name stack.sh.log 2>/dev/null`
    grep -q "This is your host ip:" 2>/dev/null ${log_file} && ${setcolor_success} || ${setcolor_failure}
    echo -n DS
    ${setcolor_normal}
    echo
}
function ksAddLineToFileIfNotThere()
{
    local line=$1
    local file=$2
    echo $line
    [ -f ${file} ] || touch ${file}
    grep "${line}" ${file} || echo ${line} >> ${file}
}
function kkmac()
{
    echo $(od -An -N6 -tx1 /dev/urandom | sed -e 's/^  *//' -e 's/  */:/g' -e 's/:$//' -e 's/^\(.\)[13579bdf]/\10/')
}
function ksvirtvm()
{
    local vm_name='build_server'
    local vm_disk_format=raw
    local vm_disk_path=${MY_TMP_DIR}/${vm_name}.${vm_disk_format}
    local vm_iso_path=/opt/trusty-server-cloudimg-amd64-disk1.img

    local cmd="virt-install --name ${vm_name} --ram 4096 --arch=i686 --vcpus=1 --hvm --graphics vnc \
        --os-variant ubuntutrusty \
        --cdrom ${vm_iso_path} \
        --disk path=${vm_disk_path},bus=virtio,size=20,sparse=false,format=${vm_disk_format}"
    echo $cmd
}
function kkvirsh()
{
    echo Virtual machines: &&  virsh list --all
    echo Virtual pools: && virsh pool-list --all
    echo Virtual networks: &&  virsh net-list --all
    echo Bridges: && brctl show
    _section
    local server=$(virsh list | grep lab | awk '{print $2}')
    alias v1="virsh console ${server}"
    alias v2="virsh vncdisplay ${server}"

    local virsh_command=$(_get_input 'kill-all new-vm')
    case ${virsh_command} in
        kill-all)
	         virsh list | awk '{print $2}' | grep -v ^Name | xargs -n 1 virsh destroy
	         virsh list --all | awk '{print $2}' | grep -v ^Name | xargs -n 1 virsh undefine
	         virsh net-list | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh net-destroy
	         virsh net-list --all | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh net-undefine
	         virsh pool-list | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh pool-destroy
	         virsh pool-list --all | awk '{print $1}' | grep -vE "^Name|^-----" | xargs -n1 virsh pool-undefine
	       ;;
        new-vm) kkvirtvm ;;
    esac
}
function ks_list_of_ifaces()
{
    echo $(ip l |grep UP | cut -f2 -d ':')
}

function ksGetInput()
{
    local text=$1
    local default=$2
    local input
    read -p "${text} [default=${default}]: " input
    echo ${input:-${default}}
}
function kkelk()
{
    local cmd=$(_get_input 'index indexR docker')
    case ${cmd} in
        index)
            curl -XGET 'localhost:9200/_cat/indices?v&pretty'

            # curl -H "Content-Type: application/json" -XPOST 'localhost:9200/resultnfvbench-2017.10.18/_bulk?pretty&refresh' --data-binary "@resultnfvbench-2017.10.18.json"
        ;;
        indexR)
            curl -XGET 'mgm.foxberry:9200/_cat/indices?v&pretty'
        ;;
        docker)
            docker run -d -p 9200:9200 -p 9300:9300 -it -h elasticsearch --name elasticsearch docker.elastic.co/elasticsearch/elasticsearch:6.0.0
            docker run -d -p 5601:5601 -h kibana --name kibana --link elasticsearch:elasticsearch -v "$HOME":/data docker.elastic.co/kibana/kibana:6.0.0
            # docker run -d -p 9500:9500 -h logstash --name logstash --link $name:$name --rm -v "$HOME":/data logstash -f /data/repo/my/logstash.conf
        ;;
    esac
}
function kkos()
{
    local nova_command=${1:-$(_get_input 'help config status')}
    case ${nova_command} in
        config)
            local devstack_config=$(find ~ -wholename '*/devstack/openrc')
            export OS_TENANT_NAME=demo
            export OS_USERNAME=demo
            export OS_PASSWORD=password
            export OS_AUTH_URL='http://localhost:5000/v2.0'
	    [ -z ${devstack_config} ] || source ${devstack_config}
        ;;
        status)
	    echo Tenant: ${OS_TENANT_NAME} User: ${OS_USER_NAME}
            nova list
	    neutron net-list
	    neutron subnet-list
	    neutron port-list
        ;;
        help)
            echo 'mysql --user=nova --password=nova nova'
            echo 'select id,cidr,project_id  from networks;'

            echo 'nova keypair-add --pub-key ~/.ssh/id_rsa.pub vaio'
            echo 'neutron security-group-rule-create --protocol icmp --ethertype=IPv6 --direction ingress default'
            echo 'neutron security-group-rule-create --protocol tcp --ethertype=IPv6 --direction ingress --port-range-min 22 --port-range-max 22 default'

            echo 'neutron net-list'
            echo 'neutron net-create ext46 --router:external --shared'
            neutron 'net-delete ext46'
            neutron 'subnet-list'
            neutron 'subnet-create ext46 10.100.0.0/16 --name=sub4'
            neutron 'subnet-create ext46 2001:db8:10::/64 --ip-version=6 --name=slaac6 --ipv6-ra-mode=slaac --ipv6-address-mod=slaac'
            neutron 'subnet-create ext46 2001:db8:20::/64 --ip-version=6 --name=stateless6 --ipv6-ra-mode=dhcpv6-stateless --ipv6-address-mod=dhcpv6-stateless'
            neutron 'subnet-create ext46 2001:db8:30::/64 --ip-version=6 --name=stateful6 --ipv6-ra-mode=dhcpv6-stateful --ipv6-address-mod=dhcpv6-stateful'

            neutron 'router-create r46'
            neutron 'router-gateway-set r46 ext46'
            neutron 'router-interface-add r6 sub6'

            nova 'boot i1 --flavor=1 --image=20e68825-3d8b-4d5c-ac84-17f1101ec643 --nic net-id=aacf221a-f348-4909-9b86-55a38b369859'
            nova 'delete i1'
        ;;
        esac
}
function kkdevstack()
{
    local devstack_command=$(_get_input 'config run result cleanup' $1)
    case ${devstack_command} in
    config)
            local conf_file_name=local.conf
	    cat > ${conf_file_name} <<EOF
[[local|localrc]]
DEST=\${HOME}/os
DATA_DIR=\${DEST}/data
SERVICE_DIR=\${DEST}/status
GIT_BASE=https://git.openstack.org
TEMPEST_REPO=https://github.com/CiscoSystems/tempest.git
TEMPEST_BRANCH=ipv6
RECLONE=True

MYSQL_PASSWORD=nova
RABBIT_PASSWORD=nova
SERVICE_TOKEN=nova
SERVICE_PASSWORD=nova
ADMIN_PASSWORD=nova

ENABLED_SERVICES=g-api,g-reg,key,n-api,n-crt,n-obj,n-cpu,n-cond,cinder,c-sch,c-api,c-vol,n-sch,n-novnc,n-xvnc,n-cauth,horizon,rabbit
enable_service mysql
disable_service n-net
enable_service q-svc
enable_service q-agt
enable_service q-l3
enable_service q-dhcp
enable_service q-meta
enable_service q-lbaas
enable_service neutron
enable_service tempest

NOVA_USE_NEUTRON_API=v2
VOLUME_BACKING_FILE_SIZE=2052M
API_RATE_LIMIT=False

VERBOSE=True
DEBUG=True

LOGFILE=\$DEST/logs/stack.sh.log
USE_SCREEN=True
SCREEN_LOGDIR=\$DEST/logs

IP_VERSION=4+6
IPV6_PUBLIC_RANGE=2005::/64
IPV6_PUBLIC_NETWORK_GATEWAY=2005::1
REMOVE_PUBLIC_BRIDGE=False
EOF
                   echo ${conf_file_name} created
        ;;
    run)
	cat ~/current_tempest && cd /opt/stack/tempest && testr run --load-list=${HOME}/current_tempest
	;;
    result)
            testr last --subunit | subunit-1to2 | subunit2junitxml --output-to=kir_results.xml
        ;;
    cleanup)
	sudo rm -rf /etc/keystone /usr/local/bin/keyston* /etc/nova /usr/local/bin/nova* /etc/neutron /usr/local/bin/neutron* /etc/glance /usr/local/bin/glance* /etc/cinder /usr/local/bin/cinder* /etc/heat
	;;
    esac
}

function kkinfo()
{   # shows usefull info about unknown command provided as argument
    local cmd_name=$1
    local cmd_full_path=`which ${cmd_name}`
    file ${cmd_full_path}
    dpkg -S ${cmd_full_path}
}

WaasSocketFile="/tmp/WAAS"
WaasTunelPort="11111"
WaasRemoteDir="kshileev@localhost:/work/kshileev/tahoe"
WaasTbMsk1Edge='172.18.6.40'
WaasTbMsk1Core='172.18.6.41'

function kkold
{
    local ClientPort=22131
    local ServerPort=22134
    local ClientIp=172.23.142.133
    local ServerIp=172.23.142.138
    local EdgeIp=2.75.57.162
    local CoreIp=2.75.57.34

    
    ssh -2NfL ${ClientPort}:${ClientIp}:3389 kshileev@xe-kite.cisco.com
    ssh -2NfL ${ServerPort}:${ServerIp}:3389 kshileev@xe-kite.cisco.com
    rdesktop -u Administrator -p watchThis  -T WinServer -g 1024x768 localhost:${ClientPort}  &
    rdesktop -u Administrator -p watchThis  -T WinClient -g 1024x768 localhost:${ServerPort}  &


    xterm -geometry 140x36+1600+10 -bg steelblue     -fg black -title "EDGE conf log disk pri not" -e ssh -S ${WaasSocketFile} kshileev@localhost telnet ${EdgeIp} &
    xterm -geometry 140x36-900-10  -bg lightblue     -fg black -title "EDGE-DBG sh conn stat" -e ssh -S ${WaasSocketFile} kshileev@localhost telnet ${EdgeIp} &
    xterm -geometry 130x36-5+10    -bg lightyellow   -fg black -title "CORE (no) acc smb ena" -e ssh -S ${WaasSocketFile} kshileev@localhost telnet ${CoreIp} &
    xterm -geometry 130x36-5-10    -bg black         -fg white -title LOCAL &
}
function WaasSocket()
{
    if [ ! -S ${WaasSocketFile} ]; then
	    echo "Creating file_socket to Cisco BLD server..."
	    ssh -2NfL ${WaasTunelPort}:adbu-bldsrv-03.cisco.com:22 kshileev@xe-kite.cisco.com
	    ssh -2Nfp ${WaasTunelPort} kshileev@localhost -M -S ${WaasSocketFile}
    fi
}
function ksWaasSyncDown
{
    if [ -d src -a -d ut -a -d include ]; then
	WaasSocket #establish tunnel to CISCO network
	local From=${WaasRemoteDir}/ao/smb/
	echo "Syncing down CISCO->LOCAL  from $From to .:"
	rsync -avz -e "ssh -S $WaasSocketFile" ${WaasExcludeList} --delete ${From} .
	echo "Finished."
    else
	echo  "Current directory must contain <include> <src> <ut>, aborting."
    fi
}
function ksWaasSyncUp
{
    if [ -d src -a -d ut -a -d include ]; then
	WaasSocket #establish tunnel to CISCO network
        local To=${WaasRemoteDir}/ao/smb
	echo "Doing LOCAL->WAAS from . to $To:"
        rsync -avz -e "ssh -S $WaasSocketFile" ${WaasExcludeList} --delete . ${To}
	echo "Finished."
    else
	echo "Current directory must contain <include> <src> <ut>, aborting."
    fi
}
function ksWaasGetRef
{
    WaasSocket #establish tunnel to CISCO network
    local Shell=${WaasRemoteDir}/ao/shell
    local Doc=${WaasRemoteDir}/derived/doc
    echo "$Shell -> .:"
    rsync -avz -e "ssh -S $WaasSocketFile" --exclude=.CC --exclude=.ACME --delete ${Shell} .
    echo "$Doc -> .:"
    rsync -avz -e "ssh -S $WaasSocketFile" --exclude=.CC --exclude=.ACME --delete ${Doc} .
    echo "Finished."
}
function ksWaasDeploySmb
{
    WaasSocket
    #local Dir=`mktemp -p /tmp -d WaasDeploySmb.XXXXXXXXXX`
    local WaasTmpDir=/tmp/WaasSmbDeploy
    mkdir -p ${WaasTmpDir}

    echo "Getting SMBAO executables ${WaasRemoteDir} ->  ${WaasTmpDir}:"
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/derived/unicorn/bin/smbao ${WaasTmpDir}
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/derived/unicorn/lib/libsmbao.so ${WaasTmpDir}
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/x86_64-derived/unicorn/bin/smbao ${WaasTmpDir}/smbao64
    rsync -az -e "ssh -S $WaasSocketFile" ${WaasRemoteDir}/x86_64-derived/unicorn/lib/libsmbao.so ${WaasTmpDir}/libsmbao64.so
    cat >  ${WaasTmpDir}/deploy_smb <<EOF

function Deploy
{
    local Main=\$PWD
    local AfterRuby="/sw/unicorn/which.variant"
    local Variant

    ls -d /local/local1/kshileev/*/
    read -p 'Choose variant: ' Variant
    [ -z \$Variant ] && echo Nothing choosen, exiting && return

    mount -o remount,rw /sw

    if [ ! -f \$AfterRuby ]; then
	echo "Running first time after ruby redeployment, saving ruby variant"
        mkdir -p \$Main/ruby
        cp /sw/unicorn/bin/smbao64 \$Main/ruby/smbao64
        cp /sw/unicorn/bin/smbao   \$Main/ruby/smbao
        cp /sw/unicorn/lib/libsmbao.so   \$Main/ruby/libsmbao.so
        cp /sw/unicorn/lib64/libsmbao.so   \$Main/ruby/libsmbao64.so
    fi

    echo Deploying \$Variant
    cp \$Variant/smbao         /sw/unicorn/bin/smbao64
    cp \$Variant/libsmbao.so   /sw/unicorn/lib/libsmbao.so
    cp \$Variant/libsmbao64.so /sw/unicorn/lib64/libsmbao.so
    echo \$Variant > \$AfterRuby
}

Deploy
tail -f ~/errorlog/smbao-errorlog.current
EOF
    cat > ${WaasTmpDir}/ps1 <<EOF
export PS1="\!:\W> "
alias k='cd /local/local1/kshileev'
alias v='cat /sw/unicorn/which.variant'
EOF
    chmod +x ${WaasTmpDir}/deploy_smb
    echo Deploying on edge ${WaasTbMsk1Edge} ....
    sshpass -p default ssh admin@${WaasTbMsk1Edge} mkdir kshileev
    sshpass -p default ssh admin@${WaasTbMsk1Edge} mkdir kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/*smbao* admin@${WaasTbMsk1Edge}:kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/deploy_smb admin@${WaasTbMsk1Edge}:kshileev/
    sshpass -p default scp ${WaasTmpDir}/ps1 admin@${WaasTbMsk1Edge}:kshileev/
    echo Deploying on core ${WaasTbMsk1Core} ....
    sshpass -p default ssh admin@${WaasTbMsk1Core} mkdir kshileev
    sshpass -p default ssh admin@${WaasTbMsk1Core} mkdir kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/*smbao* admin@${WaasTbMsk1Core}:kshileev/fromBld
    sshpass -p default scp ${WaasTmpDir}/deploy_smb admin@${WaasTbMsk1Core}:kshileev/
    sshpass -p default scp ${WaasTmpDir}/ps1 admin@${WaasTbMsk1Core}:kshileev/
    rm -rf ${WaasTmpDir}
    echo "Finished."
}
function ksWaasDeployRuby
{
    WaasSocket
    local RubyName=ruby.$(date +%Y-%m-%d)
    echo "Getting $RubyName:"
    scp -P ${WaasTunelPort} ${WaasRemoteDir}/derived/ruby.bin /var/www/${RubyName}
    echo "Executing EDGE reload" && sshpass -p default ssh admin@edge copy http install kshileev-lnx / ${RubyName}
    sshpass -p default ssh admin@edge reload force
    echo "Executing CORE reload" && sshpass -p default ssh admin@core copy http install kshileev-lnx / ${RubyName}
    sshpass -p default ssh admin@core reload force
}
function kkrepo()
{
    local repo=$(_get_input 'os-sqe rally devstack tempest cisco-networking cisco-kloudbuster barracuda ovzctl ovzkernel')
    case ${repo} in
	rally) git clone https://git.openstack.org/openstack/rally;;
	devstack) git clone https://github.com/openstack-dev/devstack.git;;
	tempest) git clone https://github.com/openstack/tempest.git;;
	os-sqe) git clone https://github.com/CiscoSystems/os-sqe.git sqe;;
	cisco-nvfbench) git clone http://gitlab.cisco.com/openstack-perf/nfvbench.git;;
	cisco-kloudbuster) https://github.com/openstack/kloudbuster.git kloud;;
    cisco-networking) https://git.openstack.org/openstack/networking-cisco netcis;;
	ovzctl) git clone git://git.openvz.org/pub/vzctl $HOME/vz/ovzctl ;;
	ovzkernel) git clone  git://git.openvz.org/pub/linux-2.6.18-openvz $HOME/vz/18-ovz ;;
	my) git clone git@github.com:kshileev/my.git ;;
    esac
}
function ksInitrd
{
    echo Operations with INITRD:
    echo 1. unzip into current dir
    echo 2. zip current dir into ~/initrd-${USER}.img
    # read -p gzip -dc | cpio -i > .
    #find . | cpio -co --quiet | gzip -c > ~/initrd.img'
    ls *initrd* /boot/initrd*
    local IrdName=$(ksGetInput 'Choose initrd image:')
    rm -rf $HOME/ird
    mkdir -p $HOME/ird
    cp ${IrdName} $HOME/ird/tmp-initrd
    cd $HOME/ird
    gzip -dc tmp-initrd | cpio -id
    rm tmp-initrd
}
function kkgrub
{
    echo Configure grub to boot just once
    echo "savedefault --default=0 --once" |grub
}
function kkscope
{
    local what=$(_get_input 'devstack c-proj')
    echo Preparing CSCOPE to browse in $PWD
    mkdir -p ${MY_CSCOPE_DIR}
    case ${what} in
	devstack) find ${PWD} -name stack.sh -o -name functions -o -name neutron > ${MY_CSCOPE_FILE_LIST} && cd ${MY_CSCOPE_DIR} && cscope -b -q && cd -
	    ;;
	c-proj)   find ${PWD} -name "*.[ch]" -o -name "*.[ch]pp" | grep -v ut/ | grep -v utils/ > ${MY_CSCOPE_FILE_LIST} && cd ${MY_CSCOPE_DIR} && cscope -b -q -k && cd -
	    cscope -b -q -k
	    ;;
    esac
}
function kklab()
{
    cd ~/repo/os-sqe
    kkvenv
    fab bash
    . tmp.aliases
    rm tmp.aliases
}
function ksAliasDefine()
{
    echo Defines aliases
    alias a='alias'
    alias df='df -h'
    alias di="gendiff . .${MY_USER} > ~/${MY_USER}.diff-xx-xxxx-`date +%Y%m%d`"
    alias du='du -h'
    alias e='echo'
    alias ee="vim ${MY_BASH_RC}"
    alias fk="find . -name \"*.${MY_USER}\""
    alias gb='git branch -vv'
    alias gc='git checkout -- . && git clean -f'
    alias gd='git diff'
    alias gf='git fetch'
    alias gl='git log'
    alias gp='git pull'
    alias gr='git remote -v'
    alias gs='git status'
    alias grc='find . -name "*.[ch]pp" -o -name "*.[ch]" | xargs grep'
    alias h='history'
    alias l='ls -F'
    alias l.='ls -dh .*'
    alias ll='ls -Flih'
    alias ll.='ls -Fldih .*'
    alias ld='ls -lad'
    alias m='less'
    alias nifed='ssh nifed'
    alias py="ipython"
    alias pss='ksShowProcess'
    alias pt="patch -p1 -b -z .${USER}"
    alias pw="ps uxwf"
    alias src=". ~/.bashrc"
    alias sslt='ps auxw |grep ssh |grep -v grep'
    alias s='ssh -o StrictHostKeyChecking=no'
    alias store='sshpass -p ubuntu ssh localadmin@store'
    alias kki="python $MY_DIR/py/cipher.py -s"
    #alias   0m64='make -j32 CC=distcc ARCH=x86_64'
    #alias   0mod="gcc -c -Wall -nostdinc -I/usr/src/linux/include"
    #alias   0RpmBld32='rpmbuild --nodeps --target=i386 --define "_sourcedir $PWD" --define "_builddir $HOME/bld"'
    #alias   0RpmBld64='rpmbuild --nodeps --target=x86_64 --define "_sourcedir $PWD" --define "_builddir $HOME/bld"'
    #alias   0RpmBld='rpmbuild --define "_sourcedir $PWD" --define "_builddir $PWD" --define "_rpmdir $HOME"'
    #alias   0vztc='echo "BASE<<4+1"; cat /var/run/vz_tc_base; cat /var/run/vz_tc_classes; tc filter show dev eth0 parent 2:'
    #alias   0vzl='vzlist -a -o ctid,hostname,ip,numproc,ostemplate'
    #alias   0vzst='vzctl set 101 --hostname changename '
#    alias   0gos='sshpass -p girl:click.bravo ssh -R 7777:localhost:22 russup@support.swsoft'
#    alias   0gred='sshpass -p 1q2w3e ssh kir@red.dragon.gdc.mirantis.sar'
#    alias   0gblu='sshpass -p 1q2w3e ssh kir@blue.dragon.gdc.mirantis.sar'
}
function kkgrep
{
    [ -z "$1" ] && echo Usage $FUNCNAME symbol || echo $1 a\is in :
    find . -name *.[ch]pp | xargs grep $1
}
function kksizeof
{
	if [ "$#" == "0" ]; then
		echo Usage: $0 c1i1
		return
	fi

	for c in $1 ;  do
		echo ${c}
	done

	Class="class Class{char c; int i;};" #

	local TmpCode=$(mktemp -u).c++ #tmp file of type /tmp/tmp.XXXXXXXX.c++ -u: don't create it (unsafe)
	local TmpBin=${TmpCode/c++/exe}

	cat > ${TmpCode} <<EOF
#include <iostream>
using namespace std;

${Class}

int main()
{
	Class obj;
	cout<<"${Class} CLS="<<sizeof(Class)<<" obj="<<sizeof(obj)<<endl;
	return 0;
}
EOF

	g++ ${TmpCode} -o ${TmpBin}
	echo Platform `uname -m`
	${TmpBin}
	rm ${TmpCode} ${TmpBin}
}
function ksDhcpd
{
	[ -f /etc/dhcpd.conf ] && ConfFile=/etc/dhcpd.conf
	cat > ${ConfFile} << EOF
authoritative;
option domain-name "barracuda";
option domain-name-servers 192.168.4.1;

subnet 10.0.0.0 netmask 255.255.255.0 {
  option routers  10.0.0.1;

  pool {
    range dynamic-bootp  10.0.0.20 10.0.0.250;
    default-lease-time 86400;
    max-lease-time 86400;
  }

  next-server 10.0.0.10;
  filename "pxelinux.0";
}
EOF
}
function kkclass
{
    local Class=$(ksGetInput 'Class name' 'KirClass')
    local Base=$(ksGetInput 'Base name' 'KirBase')
    local Ext=$(ksGetInput 'C++ extention' '.c++')
    File=${Class}${Ext}
    Header=${Class}.h

    cat > ${Header} <<EOF
#ifndef ${Class}_h"
#define ${Class}_h"

#include <$Base.h>

class ${Class} : public ${Base}
{
public:
    ${Class}();
   ~${Class}();
protected:
  ClassDef(${Class},0)
};//class ${Class}
#endif//${Class}_h
EOF

	cat > ${File} << EOF
#include \"$Header\""             >>$File;                       echo >>$File
ClassImp(${Class})"                 >>${File};                       echo >>${File}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >>${File}
${Class}::${Class}()"                 >>${File}
{//ctor
  PrintDebugStart(\"ctor\");"     >>${File}
  PrintDebugStop(\"ctor\");"      >>${File}
  return;"                        >>${File}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
${Class}::~${Class}()
{//dtor
  PrintDebugStart("dtor");
  PrintDebugStop("dtor");
  return;
}
EOF
}
function PingNode
{
   ping -c 1 $1 > /dev/null 2>&1
   [ "$?" == "0" ] ||  echo Node \"$1\" is off, aborting...
}
function kkinit()
{
    local my_env_command=$(_get_input 'local remote update' $1)
    case ${my_env_command} in
    local)
        ksAddLineToFileIfNotThere "[ -f ${MY_BASH_RC} ] && . ${MY_BASH_RC}" ~/.bashrc
	[ -L ~/.vimrc ] || ln -s ${MY_VIM_RC} ~/.vimrc
	;;
    remote)
	grep -v ^127 /etc/hosts | grep ^[1-2]
	local Node=$(ksGetInput 'Choose node where to deploy' 'NoNode')
	echo "Deploing to ${Node}:"
	scp -p ${MY_BASH_RC} ~/.bash_profile ${MY_VIM_RC} localadmin@${Node}:
	;;
    update)
	cd ${MY_DIR}
	git pull
	;;
    esac
}
function ksCheckOs
{ # we're running on deb based or rpm based OS?
  local deb=/etc/debian_version
  local rpm=/etc/redhat-release
  [ -f ${deb} ] && { echo -n "It's DEBIAN version: " ; cat ${deb}; return 1; }
  [ -f ${rpm} ] && { echo -n "It's RPM version: "    ; cat ${rpm}; return -1; }
}
function ksBuildDisketteRouter
{
# Created 05.07.2003
# Used materials:
# Linux kernel doc ramdisk.txt usually found in /usr/src/linux/Documentation

	Tar=`pwd`
	Size=4096
	Tmp=/mnt/router #where to create all the disket staff, currently directly on floppy disk
	Device=/dev/ram

	if [ ! -f ${Tar}/etc/rc.router ]; then
		echo "No $Tar file"
	exit -1
	fi

	echo "Coping linux kernel..."
	dd if=/usr/src/linux/arch/i386/boot/bzImage of=/dev/fd0 bs=1k
	echo "Force kernel to use diskette as root device"
	rdev /dev/fd0 /dev/fd0
	echo "Tell kernel where to find compressed ramdisk"
	rdev -r /dev/fd0 16984

	echo "Cleaning $Size kb of $Device..."
	dd if=/dev/zero of=${Device} bs=1k count=${Size}

	echo "Creating ram disk of $Size kb and mounting it in $Tmp..."
	[ -d ${Tmp} ] || mkdir ${Tmp}
	mke2fs -m0 ${Device} ${Size} >/dev/null 2>&1
	mount ${Device} ${Tmp}

	echo "Creating ramdisk structure in $Tmp..."
	cd ${Tar}
	cp -r * ${Tmp}

	echo "Creating dev substructure in $Tmp..."
	mknod ${Tmp}/dev/console c 5 1
	#mknod $Tmp/dev/ramdisk b 1 0

	echo "Unmounting and deleting $Tmp..."
	umount ${Tmp}
	rm -rf ${Tmp}

	echo "Creating compressed ramdisk image on diskette from $Tmp..."
	dd if=${Device} bs=1k | gzip -v9 | dd of=/dev/fd0 bs=1k seek=600
}
function cat_files()
{
	local dir=$1
	local files=$2
	for f in ${files}; do
		echo -e "\n$dir/$f:"
		cat ${dir}/${f}
		echo -e "<----\tend\t----"
	done
}
function kkafs()
{
	service openafs-server status
	service openafs-client status
	echo -e "\n\n**\t**\tSTATUS:\t**\t**\n"
	echo ++++++++++++++++++++Server:
	ls -F "/usr/afs/{etc,db,logs,local}*";	files='ThisCell CellServDB';	cat_files /usr/afs/etc ${files}
					files='BosConfig';		cat_files /usr/afs/local ${files}
	echo ++++++++++++++++++++Client:
	ls -F /usr/vice/*; files='ThisCell CellServDB.local cacheinfo'; cat_files /usr/vice/etc ${files}

	echo +++++++++++++++++++/vicepa:
	ls -F /vicepa/

	echo -e "**\t**\tFINISHED\t**\t**"
	#echo BOS status:;	bos status localhost -localauth
	#echo BOS users:;	bos listusers localhost -localauth
	#echo BOS hosts:;	bos listhosts localhost -localauth
	#echo BOS keys:;	bos listkeys localhost -localauth
	echo asetkey:;		asetkey list
	#echo VOS volumes:;	vos listvol localhost -localauth
}
function PingNodeOrExit()
{
   ping -c 1 $1 > /dev/null 2>&1
   [ "$?" == "0" ] || { echo Node \"$1\" is off, aborting...; exit 1; }
}
function ksIntallKernel2Remote
{
    grep "Linux kernel release" README >/dev/null 2>&1
    [ $? -ne 0 ] && echo You need to invoke this from head of kernel tree && return 1
    echo Install new kernel
    ls configs/
    local Node=$(ksGetInput 'remote node name' 'tom')
    PingNodeOrExit ${Node}
    local Arch=$(_get_input 'x86_64 i386')
    local Conf=$(_get_input '.config')
    [ -z "$Conf" ] || cp configs/${Conf} .config
    make ARCH=${Arch} nonint_oldconfig   ; [ "$?" != "0" ] && return 1
    make ARCH=${Arch}                    ; [ "$?" != "0" ] && return 1

    Release=$(make kernelversion)

    Dir=$HOME/tmp ;    mkdir -p ${Dir} ;    mkdir -p ${Dir}/boot
    INSTALL_MOD_PATH=${Dir} make modules_install
                      cp arch/${Arch}/boot/bzImage  ${Dir}/boot/vmlinuz-${Release}
                      cp System.map               ${Dir}/boot/System.map-${Release}
    chmod -x vmlinux; cp vmlinux                  ${Dir}/boot/vmlinux-${Release}
                      cp .config                  ${Dir}/boot/config-${Release}

    Tarball=$HOME/tst-kernel-${Release}.tgz
    cd ${Dir} ; tar czf ${Tarball} * ;  scp ${Tarball} root@${Node}:/ ;  rm -rf ${Dir} ${Tarball}
}

function ksOvzNewCt
{
  echo "OS templates, currently installed:"
  vzpkg list
  vzpkgls
  local NumCt=$(ksGetInput 'How many CTs' '1')
  local Ostmpl=$(ksGetInput 'Which OS template')
  [ "$NumCt" == "1" ] && names="241"
  [ "$NumCt" == "2" ] && names="241 242"
  [ "$NumCt" == "3" ] && names="241 242 243"
  [ "$NumCt" == "4" ] && names="241 242 243 244"
  [ "$NumCt" == "5" ] && names="241 242 243 244 245"
  for ctid in ${names}; do
    cthn=k${ctid}.ct
    ctip=10.0.15.${ctid}
    vzctl create ${ctid} --ostemplate ${OsTmpl}
    vzctl set ${ctid} --ipadd ${ctip} --hostname ${cthn} --userpasswd root:1q2w3e --save
    vzctl start ${ctid}
  done
}
function kknet()
{
    local net_cmd=$(_get_input 'kkhelp-net sh-kern tcpdump del-nic del-netns')
    echo ${net_cmd}
    case ${net_cmd} in

    sh-kern)
	sudo sysctl -a | grep forward
	echo
	sudo sysctl -a |grep bridge
	echo
	sudo sysctl -a | grep use_tempaddr
	;;
    tcpdump)
	    ifaces=$(ks_list_of_ifaces)
	    iface=$(_get_input "${ifaces}")
	    filter=$(_get_input 'icmp6 dns dhcp')
	    case ${filter} in
	        dns) filter='port 53' ;;
            dhcp) filter='((port 67 or port 68) and (udp[8:1] = 0x1))' ;;
  	    esac
	    sudo tcpdump -n -e -l -i ${iface} ${filter} -vv
	;;
    del-nic)
	    ip a
	    local re=$(ksGetInput 'enter re' 'q.*')
	    for interface in `ip a | grep -E ${re}: | cut -f2 -d ':'`; do
	        echo Deleting interface ${interface}...
	        sudo ip l d ${interface}
	    done
    ;;
    del-netns)
	    for namespace in `ip net`; do
	        echo Deleting namespace ${namespace}...
	        sudo ip net d ${namespace}
	    done
    ;;
    esac
}

function ksTailLogAfs
{
    cd /var/log
    if ksCheckOs; then
	tail -F daemon.log user.log autgh.log debug kern.log dmesg messages \
	    kerveros/krb5kdc.log kerveros/kadmin.log kerveros/krb2lib.log \
	    openafs/BosLog openafs/FileLog openafs/SalvageLog openafs/VLLog openafs/VolserLog
    else
	tail -F messages yum.log kadmin.log krb2kdc.log krb5libs.log /usr/afs/logs/*Log	
    fi
}
function kkntp
{
    echo Creating ntp config in /etc/ntp.conf
    cat > /etc/ntp.conf <<EOF
driftfile /var/lib/ntp/drift

restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery

restrict 127.0.0.1 
restrict -6 ::1

server dn11.kirshil.ru

includefile /etc/ntp/crypto/pw

keys /etc/ntp/keys
EOF
}
function kk_deploy_key_pair()
{ # Check that ssh private-public is indeed a pair and deploy them to the given server
    local what_to_deploy=$1
    local private=$2
    local server=$3
    local user=$4
    local password=$5

    if [[ ${what_to_deploy} == "-h" ]]; then
	echo "Usage: $0 [public|private] priv_key_path host user password"
	return
    fi
    [[ -z ${what_to_deploy} ]] && what_to_deploy=public
    [[ -z ${private} ]] && private=${MY_DIR}/keys/kir_no_secret
    [[ -z ${server} ]] && server=localhost
    [[ -z ${user} ]] && user=localadmin
    [[ -z ${password} ]] && password=ubuntu

    local public=${private}.pub
    local fingerprint=$(ssh-keygen -lf ${private})
    local public_value=$(cat ${public})
    local private_value=$(cat ${private})
    local public_value_from_private=$(ssh-keygen -yf ${private})

    if [[ ${public_value} = ${public_value_from_private}* ]]; then
	echo "${public} -> ${fingerprint}"
	case ${what_to_deploy} in
	    private) sshpass -p ${password} scp ${private} ${user}@${server}:~/.ssh/id_rsa;;
	    public) sshpass -p ${password} ssh ${user}@${server} echo ${public_value} >> ~/.ssh/authorized_keys;;
	esac
    else
	echo "${private} and ${public} are not a match!"
    fi
}
function kksecurity()
{ # manipulate with ssh keys
    local ssh_command=${1:-$(_get_input 'deploy-to finger self-signed-certificate')}
    case ${ssh_command} in
    deploy-to)
      local host
      curl -s https://wwwin-gitlab-sjc.cisco.com/mercury/configs/raw/master/private.key -o OsSqeUser && chmod 400 OsSqeUser && ssh-add OsSqeUser && chmod 600 OsSqeUser && rm OsSqeUser
      ssh-copy-id localadmin@jm
      ssh-copy-id localadmin@store
    ;;
    pair-cert)
	echo Operations with p12 and pem public-private pairs
        ls ${MY}/keys/* ${HOME}/.ssh/*
	local Public=$(ksGetInput 'Public  key'); [[ -z $Public ]] && return
	local Private=$(ksGetInput 'Private  key'); [[ -z $Private ]] && return

        local out1=$(openssl rsa -in ${Private} -noout -modulus)
        local out2=$(openssl x509 -in ${Public} -noout -modulus)
        echo ${Public} and ${Private}
        [ "$out1" == "$out2" ] && echo "are pair" || echo "are NOT pair"
    ;;
    finger)
      ssh-add -l -E md5
    ;;
    self-signed-certificate)
      openssl req -x509 -newkey rsa:4096 -keyout KirSelfSignedCertKey.pem -out KirSelfSignedCert.pem -days 365
    ;;
    esac
}
function kkps()
{
    local name=$1
    local pid=$2
    ps -C ${name} -o user,pid,ppid,cmd
    [[ -n ${pid} ]] && ps -p ${pid} -o user,pid,ppid,cmd
}
function kkvenv()
{
    git status || return
    local dir=${MY_VENV_DIR}/$(git remote -v | grep fetch | cut -d / -f 5 | cut -d . -f 1)
    [ -d ${dir} ] || virtualenv ${dir}
    . ${dir}/bin/activate
    pip install -r requirements.txt
}
function ksKloudBuster()
{
    ls ~
    local cloud_rc=$(ksGetInput 'Choose cloud'); [[ -z $cloud_rc ]] && return
    cd ~/os/kloud/kloudbuster
    python kloudbuster.py --tested-rc ~/${cloud_rc} --tested-passwd admin --json ~/kloud.json
    python kb_gen_chart.py -c ~/kloud.html ~/kloud.json
    rm -f ~/kloud.json
}
function ksSshTo()
{
    host=${1}
    username=${2}
    password=${3}

    echo ssh ${username}@${host} with ${password}
    sshpass -p ${password} ssh ${username}@${host}

}
function kklog()
{
    local log_file=$1
    local log_regex=$2
    local minutes=$3
    sed -n "/^$(date +%Y-%m-%d\ %H:%M --date="$minutes min ago")/, /^$(date +%Y-%m-%d\ %H:%M)/p" $log_file | grep -i $log_regex
}
function kkssh()
{
    ssh $1 || echo Problem
}
ksAliasDefine

[[ -f /etc/bash_completion ]] && . /etc/bash_completion
source ${MY_DIR}/HelpBash
